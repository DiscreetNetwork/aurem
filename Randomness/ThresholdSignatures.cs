using Aurem.ECC;
using Aurem.ECC.Native;

/// <summary>
/// Implementation of components needed to achieve Common Randomness for Common
/// Vote among the nodes in Aurem.
/// </summary>
namespace Aurem.Randomness
{
    /// <summary>
    /// </summary>
    class ThresholdSignature
    {
        private int threshold;
        private int nParties;

        public ThresholdSignature(int _threshold, int _nParties)
        {
            threshold = _threshold;
            nParties = _nParties;
         }

        /// <summary>
        /// GenerateKeys
        /// </summary>
        public (VerificationKey vkey, List<SecretKey> skeys) GenerateKeys()
        {
            AltBn128G2 G2 = Native.Instance.G2();
            // Generating a set of coefficients.
            List<BigInt> ZRs = new();
            for (int c = 0; c < threshold; c++) {
                ZRs.Add(Native.Instance.RandomCoefficient());
            }
            BigInt secret = ZRs[threshold-1];

            // Generating secret keys.
            List<BigInt> sks = new();
            for (ulong c = 1; c < (ulong)nParties + 1; c++)
                sks.Add(EvaluatePolynomial(ZRs, new BigInt(c)));

            // Generating verification keys.
            AltBn128G2 vk = Native.Instance.ScalarMulG2(secret);
            List<AltBn128G2> vks = new();

            foreach (BigInt sk in sks)
                vks.Add(Native.Instance.ScalarMulG2(sk));

            // Secret message.
            BigInt msg = new BigInt(123123123);
            AltBn128G1 msgHash = Native.Instance.ScalarMulG1(msg);

            // Generating shares of the message.
            List<AltBn128G1> shares = new();
            foreach(BigInt sk in sks)
                shares.Add(Native.Instance.ScalarPointMulG1(msgHash, sk));

            // // Validating shares.
            // for (int c = 0; c < nParties; c++) {
            //     Console.WriteLine(Native.Instance.PairsEqual(msgHash, vks[c], shares[c], G2));
            // }

            VerificationKey verificationKey = new(threshold, vk, vks);
            List<SecretKey> secretKeys = new();

            foreach(BigInt sk in sks)
                secretKeys.Add(new SecretKey(sk));

            return (verificationKey, secretKeys);
        }

        private BigInt EvaluatePolynomial(List<BigInt> coefficients, BigInt x)
        {
            BigInt result = new BigInt(0);
            for (int c = 0; c < coefficients.Count; c++) {
                // x * y + coef, and we reduce.
                result = Native.Instance.ModOrder(BigInt.Add(result, BigInt.Add(coefficients[c], BigInt.Multiply(x, result))));
            }
            return result;
        }
    }

    /// <summary>
    /// </summary>
    class VerificationKey
    {
        private int threshold;
        private AltBn128G2 vk;
        private List<AltBn128G2> vks;
        private AltBn128G2 G2;

        public VerificationKey(int _threshold, AltBn128G2 _vk, List<AltBn128G2> _vks) {
            threshold = _threshold;
            vk = _vk;
            vks = _vks;
            G2 = Native.Instance.G2();
        }

        /// <summary>
        /// </summary>
        private void Lagrange()
        {

        }

        /// <summary>
        /// </summary>
        private void CombineShares()
        {

        }

        /// <summary>
        /// Verifies if the share of a message hash was generated by the party
        /// who owns the verification key at vkIdx.
        /// </summary>
        private bool VerifyShare(AltBn128G1 share, int vkIdx, AltBn128G1 msgHash)
        {
            return Native.Instance.PairsEqual(msgHash, vks[vkIdx], share, G2);
        }

        /// <summary>
        /// </summary>
        private bool VerifySignature(AltBn128G1 signature, AltBn128G1 msgHash)
        {
            return Native.Instance.PairsEqual(msgHash, vk, signature, G2);
        }
    }

    /// <summary>
    /// </summary>
    class SecretKey
    {
        private BigInt sk;

        public SecretKey(BigInt _sk)
        {
            sk = _sk;
        }

        /// <summary>
        /// </summary>
        private AltBn128G1 GenerateShare(AltBn128G1 msgHash)
        {
            return Native.Instance.ScalarPointMulG1(msgHash, sk);
        }
    }
}
